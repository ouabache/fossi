//////////////////////////////////////////////////////////////////////
////                                                              ////
////  uart_regs.v                                                 ////
////                                                              ////
////                                                              ////
////  This file is part of the "UART 16550 compatible" project    ////
////  http://www.opencores.org/cores/uart16550/                   ////
////                                                              ////
////  Documentation related to this project:                      ////
////  - http://www.opencores.org/cores/uart16550/                 ////
////                                                              ////
////  Projects compatibility:                                     ////
////  - WISHBONE                                                  ////
////  RS232 Protocol                                              ////
////  16550D uart (mostly supported)                              ////
////                                                              ////
////  Overview (main Features):                                   ////
////  Registers of the uart 16550 core                            ////
////                                                              ////
////  Known problems (limits):                                    ////
////  Inserts 1 wait state in all WISHBONE transfers              ////
////                                                              ////
////  To Do:                                                      ////
////  Nothing or verification.                                    ////
////                                                              ////
////  Author(s):                                                  ////
////      - gorban@opencores.org                                  ////
////      - Jacob Gorban                                          ////
////      - Igor Mohor (igorm@opencores.org)                      ////
////                                                              ////
////  Created:        2001/05/12                                  ////
////  Last Updated:   (See log for the revision history           ////
////                                                              ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000, 2001 Authors                             ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// CVS Revision History
//
// $Log: not supported by cvs2svn $
// Revision 1.41  2004/05/21 11:44:41  tadejm
// Added synchronizer flops for RX input.
//
// Revision 1.40  2003/06/11 16:37:47  gorban
// This fixes errors in some cases when data is being read and put to the FIFO at the same time. Patch is submitted by Scott Furman. Update is very recommended.
//
// Revision 1.39  2002/07/29 21:16:18  gorban
// The uart_defines.v file is included again in sources.
//
// Revision 1.38  2002/07/22 23:02:23  gorban
// Bug Fixes:
//  * Possible loss of sync and bad reception of stop bit on slow baud rates fixed.
//   Problem reported by Kenny.Tung.
//  * Bad (or lack of ) loopback handling fixed. Reported by Cherry Withers.
//
// Improvements:
//  * Made FIFO's as general inferrable memory where possible.
//  So on FPGA they should be inferred as RAM (Distributed RAM on Xilinx).
//  This saves about 1/3 of the Slice count and reduces P&R and synthesis times.
//
//
// Revision 1.37  2001/12/27 13:24:09  mohor
// lsr[7] was not showing overrun errors.
//
// Revision 1.36  2001/12/20 13:25:46  mohor
// rx push changed to be only one cycle wide.
//
// Revision 1.35  2001/12/19 08:03:34  mohor
// Warnings cleared.
//
// Revision 1.34  2001/12/19 07:33:54  mohor
// Synplicity was having troubles with the comment.
//
// Revision 1.33  2001/12/17 10:14:43  mohor
// Things related to msr register changed. After THRE IRQ occurs, and one
// character is written to the transmit fifo, the detection of the THRE bit in the
// LSR is delayed for one character time.
//
// Revision 1.32  2001/12/14 13:19:24  mohor
// MSR register fixed.
//
// Revision 1.31  2001/12/14 10:06:58  mohor
// After reset modem status register MSR should be reset.
//
// Revision 1.30  2001/12/13 10:09:13  mohor
// thre irq should be cleared only when being source of interrupt.
//
// Revision 1.29  2001/12/12 09:05:46  mohor
// LSR status bit 0 was not cleared correctly in case of reseting the FCR (rx fifo).
//
//
// Revision 1.27  2001/12/06 14:51:04  gorban
// Bug in LSR[0] is fixed.
// All WISHBONE signals are now sampled, so another wait-state is introduced on all transfers.
//
// Revision 1.26  2001/12/03 21:44:29  gorban
// Updated specification documentation.
// Added full 32-bit data bus interface, now as default.
// Address is 5-bit wide in 32-bit data bus mode.
// Added wb_sel_i input to the core. It's used in the 32-bit mode.
// Added debug interface with two 32-bit read-only registers in 32-bit mode.
// Bits 5 and 6 of LSR are now only cleared on TX FIFO write.
// My small test bench is modified to work with 32-bit mode.
//
// Revision 1.25  2001/11/28 19:36:39  gorban
// Fixed: timeout and break didn't pay attention to current data format when counting time
//
// Revision 1.24  2001/11/26 21:38:54  gorban
// Lots of fixes:
// Break condition wasn't handled correctly at all.
// LSR bits could lose their values.
// LSR value after reset was wrong.
// Timing of THRE interrupt signal corrected.
// LSR bit 0 timing corrected.
//
// Revision 1.23  2001/11/12 21:57:29  gorban
// fixed more typo bugs
//
// Revision 1.22  2001/11/12 15:02:28  mohor
// lsr1r error fixed.
//
// Revision 1.21  2001/11/12 14:57:27  mohor
// ti_int_pnd error fixed.
//
// Revision 1.20  2001/11/12 14:50:27  mohor
// ti_int_d error fixed.
//
// Revision 1.19  2001/11/10 12:43:21  gorban
// Logic Synthesis bugs fixed. Some other minor changes
//
// Revision 1.18  2001/11/08 14:54:23  mohor
// Comments in Slovene language deleted, few small fixes for better work of
// old tools. IRQs need to be fix.
//
// Revision 1.17  2001/11/07 17:51:52  gorban
// Heavily rewritten interrupt and LSR subsystems.
// Many bugs hopefully squashed.
//
// Revision 1.16  2001/11/02 09:55:16  mohor
// no message
//
// Revision 1.15  2001/10/31 15:19:22  gorban
// Fixes to break and timeout conditions
//
// Revision 1.14  2001/10/29 17:00:46  gorban
// fixed parity sending and tx_fifo resets over- and underrun
//
// Revision 1.13  2001/10/20 09:58:40  gorban
// Small synopsis fixes
//
// Revision 1.12  2001/10/19 16:21:40  gorban
// Changes data_out to be synchronous again as it should have been.
//
// Revision 1.11  2001/10/18 20:35:45  gorban
// small fix
//
// Revision 1.10  2001/08/24 21:01:12  mohor
// Things connected to parity changed.
// Clock devider changed.
//
// Revision 1.9  2001/08/23 16:05:05  mohor
// Stop bit bug fixed.
// Parity bug fixed.
// WISHBONE read cycle bug fixed,
// OE indicator (Overrun Error) bug fixed.
// PE indicator (Parity Error) bug fixed.
// Register read bug fixed.
//
// Revision 1.10  2001/06/23 11:21:48  gorban
// DL made 16-bit long. Fixed transmission/reception bugs.
//
// Revision 1.9  2001/05/31 20:08:01  gorban
// FIFO changes and other corrections.
//
// Revision 1.8  2001/05/29 20:05:04  gorban
// Fixed some bugs and synthesis problems.
//
// Revision 1.7  2001/05/27 17:37:49  gorban
// Fixed many bugs. Updated spec. Changed FIFO files structure. See CHANGES.txt file.
//
// Revision 1.6  2001/05/21 19:12:02  gorban
// Corrected some Linter messages.
//
// Revision 1.5  2001/05/17 18:34:18  gorban
// First 'stable' release. Should be sythesizable now. Also added new header.
//
// Revision 1.0  2001-05-17 21:27:11+02  jacob
// Initial revision
//
//
module `VARIANT`REGS 
  #(parameter PRESCALER_PRESET = 16'h0000 )
   ( 
   input  wire                             clk,
   input  wire                             wb_rst_i,
   input  wire [15:0]                      wb_dat_i,
   input  wire [7:0]                       tr_reg_wdata,
   input  wire [3:0]                       ie_reg_wdata,

   input  wire                             wb_we_i,
   input  wire                             wb_re_i,
   input  wire                             tr_reg_wr,
   input  wire                             rb_dll_reg_rd,


   input  wire                             ls_reg_rd,
   input  wire                             ms_reg_rd,
   input  wire                             ii_reg_rd,
   input  wire                             ie_reg_wr,

   input  wire                             cts_pad_i,
   input  wire                             dsr_pad_i,
   input  wire                             ri_pad_i,
   input  wire                             dcd_pad_i,
   input  wire                             srx_pad_i,


   output wire                             stx_pad_o,
   output wire                             rts_pad_o,
   output wire                             dtr_pad_o,
   output  reg                             int_o,
   output wire                             baud_o,
   output  reg  [3:0]                      ier,
   output  reg  [3:0]                      iir,
   input  wire  [7:0]                      fcr,
   input  wire  [4:0]                      mcr,
   input  wire  [7:0]                      lcr,
   output  reg  [7:0]                      msr,
   output wire  [7:0]                      lsr,
   output wire  [`UART_FIFO_COUNTER_W-1:0] rf_count,
   output wire  [`UART_FIFO_COUNTER_W-1:0] tf_count,
   output wire  [2:0]                      tstate,
   output wire  [3:0]                      rstate,
   output wire  [7:0]                      rdata_rb_dll,
   output wire  [7:0]                      rdata_ie_dlh

          );



   reg                      enable;
   wire                     srx_pad;

   reg [15:0]               dl;  // 32-bit divisor latch

   reg                      start_dlc; // activate dlc on writing to UART_DL1
   reg                      lsr_mask_d; // delay for lsr_mask condition
   reg                      msi_reset; // reset MSR 4 lower bits indicator
   //reg                                         threi_clear; // THRE interrupt clear flag
   reg [15:0]               dlc;  // 32-bit divisor latch counter

   reg [3:0]                trigger_level; // trigger level of the receiver FIFO
   reg                      rx_reset;
   reg                      tx_reset;

   wire                     dlab;               // divisor latch access bit

   wire                     loopback;           // loopback bit (MCR bit 4)
   wire                     cts, dsr, ri, dcd;       // effective signals
   wire                     cts_c, dsr_c, ri_c, dcd_c; // Complement effective signals (considering loopback)


   // LSR bits wires and regs

   wire                  lsr0, lsr1, lsr2, lsr3, lsr4, lsr5, lsr6, lsr7;
   reg                      lsr0r, lsr1r, lsr2r, lsr3r, lsr4r, lsr5r, lsr6r, lsr7r;
   wire                  lsr_mask; // lsr_mask


   // Interrupt signals
   wire                  rls_int;  // receiver line status interrupt
   wire                  rda_int;  // receiver data available interrupt
   wire                  ti_int;   // timeout indicator interrupt
   wire                  thre_int; // transmitter holding register empty interrupt
   wire                  ms_int;   // modem status interrupt

   // FIFO signals
   reg                      tf_push;
   reg                      rf_pop;
   wire [`UART_FIFO_REC_WIDTH-1:0]   rf_data_out;
   wire                  rf_error_bit; // an error (parity or framing) is inside the fifo
   wire                  rf_overrun;
   wire                  rf_push_pulse;   


   wire [9:0]                  counter_t;

   wire                  thre_set_en; // THRE status is delayed one character time when a character is written to fifo.
   reg [7:0]                  block_cnt;   // While counter counts, THRE status is blocked (delayed one character cycle)
   reg [7:0]                  block_value; // One character length minus stop bit

   // Transmitter Instance
   wire                  serial_out;

   wire                  serial_in;

   wire     lsr_mask_condition;
   wire     iir_read;
   wire     msr_read;
   wire     fifo_read;
   wire     fifo_write;

   wire  rls_int_rise;
   wire  thre_int_rise;
   wire  ms_int_rise;
   wire  ti_int_rise;
   wire  rda_int_rise;

   reg      lsr0_d;
   reg      lsr1_d; // delayed

   reg      lsr2_d; // delayed

   reg      lsr3_d; // delayed
   reg      lsr4_d; // delayed
   reg      lsr5_d;
   reg      lsr6_d;

   reg      lsr7_d;


   reg      rls_int_d;
   reg      thre_int_d;
   reg      ms_int_d;
   reg      ti_int_d;
   reg      rda_int_d;

   reg      rls_int_pnd;
   reg      rda_int_pnd;
   reg      thre_int_pnd;
   reg      ms_int_pnd;
   reg      ti_int_pnd;


   //
   // ASSIGNS
   //

   assign              rdata_rb_dll = dlab ? dl[7:0]  : rf_data_out[10:3];
   assign              rdata_ie_dlh = dlab ? dl[15:8] : {4'd0,ier};


   assign baud_o = enable; // baud_o is actually the enable signal

   assign                                     lsr[7:0] = { lsr7r, lsr6r, lsr5r, lsr4r, lsr3r, lsr2r, lsr1r, lsr0r };


   assign                                     {cts, dsr, ri, dcd} = ~{cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};

   assign                  {cts_c, dsr_c, ri_c, dcd_c} = loopback ? {mcr[`UART_MC_RTS],mcr[`UART_MC_DTR],mcr[`UART_MC_OUT1],mcr[`UART_MC_OUT2]}
   : {cts_pad_i,dsr_pad_i,ri_pad_i,dcd_pad_i};

   assign                                     dlab = lcr[`UART_LC_DL];
   assign                                     loopback = mcr[4];

   // assign modem outputs
   assign                                     rts_pad_o = mcr[`UART_MC_RTS];
   assign                                     dtr_pad_o = mcr[`UART_MC_DTR];
   // handle loopback
   assign                  serial_in = loopback ? serial_out : srx_pad;
   assign stx_pad_o = loopback ? 1'b1 : serial_out;




   `VARIANT`TRANSMITTER  transmitter(
        .clk             (clk), 
        .wb_rst_i        (wb_rst_i), 
        .lcr             (lcr), 
        .tf_push         (tf_push), 
        .tf_data_in      (tr_reg_wdata), 
        .enable          (enable), 
        .stx_pad_o       (serial_out), 
        .tstate          (tstate), 
        .tf_count        (tf_count), 
        .tx_reset        (tx_reset), 
        .lsr_mask        (lsr_mask));



   // Synchronizing and sampling serial RX input
   `VARIANT`SYNC_FLOPS     
    #(.width(1),
      .init_value(1'b1))
    i_uart_sync_flops
     (
      .rst_i           (wb_rst_i),
      .clk_i           (clk),
      .stage1_rst_i    (1'b0),
      .stage1_clk_en_i (1'b1),
      .async_dat_i     (srx_pad_i),
      .sync_dat_o      (srx_pad)
      );



 


   // Receiver Instance
   `VARIANT`RECEIVER  receiver(
                .clk               (clk), 
                .wb_rst_i          (wb_rst_i), 
                .lcr               (lcr), 
                .rf_pop            (rf_pop), 
                .srx_pad_in        (serial_in), 
                .enable            (enable), 
                .counter_t         (counter_t), 
                .rf_count          (rf_count), 
                .rf_data_out       (rf_data_out), 
                .rf_error_bit      (rf_error_bit), 
                .rf_overrun        (rf_overrun),  
                .rx_reset          (rx_reset), 
                .lsr_mask          (lsr_mask), 
                .rstate            (rstate), 
                .rf_push_pulse     ( rf_push_pulse)

);



   // rf_pop signal handling
   always @(posedge clk )
     begin
    if (wb_rst_i)
      rf_pop <=  0; 
    else
      if (rf_pop)    // restore the signal to 0 after one clock cycle
        rf_pop <=  0;
      else
        if (wb_re_i && rb_dll_reg_rd && !dlab)
          rf_pop <=  1; // advance read pointer
     end



   assign lsr_mask_condition = (wb_re_i && ls_reg_rd && !dlab);
   assign iir_read = (wb_re_i && ii_reg_rd && !dlab);
   assign msr_read = (wb_re_i && ms_reg_rd && !dlab);
   assign fifo_read = (wb_re_i && rb_dll_reg_rd && !dlab);
   assign fifo_write = (tr_reg_wr && wb_we_i && !dlab);

   // lsr_mask_d delayed signal handling
   always @(posedge clk )
     begin
    if (wb_rst_i)
      lsr_mask_d <=  0;
    else // reset bits in the Line Status Register
      lsr_mask_d <=  lsr_mask_condition;
     end

   // lsr_mask is rise detected
   assign lsr_mask = lsr_mask_condition && ~lsr_mask_d;

   // msi_reset signal handling
   always @(posedge clk )
     begin
    if (wb_rst_i)
      msi_reset <=  1;
    else
      if (msi_reset)
        msi_reset <=  0;
      else
        if (msr_read)
          msi_reset <=  1; // reset bits in Modem Status Register
     end




   // Interrupt Enable Register

   always @(posedge clk )
     if (wb_rst_i)
       begin
      ier <=  4'b0000; // no interrupts after reset
       end
     else
       if (wb_we_i && ie_reg_wr && !dlab)
       ier <=  ie_reg_wdata; 




   // UART_DL2

   always @(posedge clk )
     if (wb_rst_i)       dl[15:8] <=  PRESCALER_PRESET[15:8];
     else
     if (wb_we_i && ie_reg_wr && dlab)
       dl[15:8] <=          wb_dat_i[15:8];

    


   // UART_DL1
   always @(posedge clk )
     if (wb_rst_i)
        dl[7:0]   <=  PRESCALER_PRESET[7:0];
     else
     if (tr_reg_wr && wb_we_i  && dlab)
         dl[7:0]   <=  wb_dat_i[7:0];










   // FIFO Control Register and rx_reset, tx_reset signals
   always @(posedge clk )
     if (wb_rst_i) begin
    rx_reset <=  0;
    tx_reset <=  0;
     end else
       begin
      rx_reset <=  fcr[2];
      tx_reset <=  fcr[1];
       end





   // TX_FIFO 
   always @(posedge clk )
     if (wb_rst_i)
       begin
      tf_push   <=  1'b0;
      start_dlc <=  1'b0;
       end
     else
       if (tr_reg_wr && wb_we_i)
     if (dlab)
       begin
          start_dlc <=  1'b1; // enable DL counter
          tf_push   <=  1'b0;
       end
     else
       begin
          tf_push   <=  1'b1;
          start_dlc <=  1'b0;
       end // else: !if(dlab)
       else
     begin
        start_dlc <=  1'b0;
        tf_push   <=  1'b0;
     end // else: !if(dlab)







   // Receiver FIFO trigger level selection logic (asynchronous mux)
   always @(fcr)
     case (fcr[`UART_FC_TL])
       2'b00 : trigger_level = 1;
       2'b01 : trigger_level = 4;
       2'b10 : trigger_level = 8;
       2'b11 : trigger_level = 14;
     endcase // case(fcr[`UART_FC_TL])
   
   //
   //  STATUS REGISTERS  //
   //

   // Modem Status Register
   reg [3:0] delayed_modem_signals;
   always @(posedge clk )
     begin
    if (wb_rst_i)
      begin
           msr <=  0;
         delayed_modem_signals[3:0] <=  0;
      end
    else begin
       msr[`UART_MS_DDCD:`UART_MS_DCTS] <=  msi_reset ? 4'b0 :
                        msr[`UART_MS_DDCD:`UART_MS_DCTS] | ({dcd, ri, dsr, cts} ^ delayed_modem_signals[3:0]);
       msr[`UART_MS_CDCD:`UART_MS_CCTS] <=  {dcd_c, ri_c, dsr_c, cts_c};
       delayed_modem_signals[3:0] <=  {dcd, ri, dsr, cts};
    end
     end


   // Line Status Register

   // activation conditions
   assign lsr0 = (rf_count==0 && rf_push_pulse);  // data in receiver fifo available set condition
   assign lsr1 = rf_overrun;     // Receiver overrun error
   assign lsr2 = rf_data_out[1]; // parity error bit
   assign lsr3 = rf_data_out[0]; // framing error bit
   assign lsr4 = rf_data_out[2]; // break error in the character
   assign lsr5 = (tf_count==5'b0 && thre_set_en);  // transmitter fifo is empty
   assign lsr6 = (tf_count==5'b0 && thre_set_en && (tstate == /*`S_IDLE */ 0)); // transmitter empty
   assign lsr7 = rf_error_bit | rf_overrun;

   // lsr bit0 (receiver data available)


   always @(posedge clk )
     if (wb_rst_i) lsr0_d <=  0;
     else lsr0_d <=  lsr0;

   always @(posedge clk )
     if (wb_rst_i) lsr0r <=  0;
     else lsr0r <=  (rf_count==1 && rf_pop && !rf_push_pulse || rx_reset) ? 0 : // deassert condition
            lsr0r || (lsr0 && ~lsr0_d); // set on rise of lsr0 and keep asserted until deasserted 

   // lsr bit 1 (receiver overrun)

   always @(posedge clk )
     if (wb_rst_i) lsr1_d <=  0;
     else lsr1_d <=  lsr1;

   always @(posedge clk )
     if (wb_rst_i) lsr1r <=  0;
     else    lsr1r <=     lsr_mask ? 0 : lsr1r || (lsr1 && ~lsr1_d); // set on rise

   // lsr bit 2 (parity error)

   always @(posedge clk )
     if (wb_rst_i) lsr2_d <=  0;
     else lsr2_d <=  lsr2;

   always @(posedge clk )
     if (wb_rst_i) lsr2r <=  0;
     else lsr2r <=  lsr_mask ? 0 : lsr2r || (lsr2 && ~lsr2_d); // set on rise

   // lsr bit 3 (framing error)



   always @(posedge clk )
     if (wb_rst_i) lsr3_d <=  0;
     else lsr3_d <=  lsr3;

   always @(posedge clk )
     if (wb_rst_i) lsr3r <=  0;
     else lsr3r <=  lsr_mask ? 0 : lsr3r || (lsr3 && ~lsr3_d); // set on rise

   // lsr bit 4 (break indicator)




   always @(posedge clk )
     if (wb_rst_i) lsr4_d <=  0;
     else lsr4_d <=  lsr4;

   always @(posedge clk )
     if (wb_rst_i) lsr4r <=  0;
     else lsr4r <=  lsr_mask ? 0 : lsr4r || (lsr4 && ~lsr4_d);

   // lsr bit 5 (transmitter fifo is empty)



   always @(posedge clk )
     if (wb_rst_i) lsr5_d <=  1;
     else lsr5_d <=  lsr5;

   always @(posedge clk )
     if (wb_rst_i) lsr5r <=  1;
     else lsr5r <=  (fifo_write) ? 0 :  lsr5r || (lsr5 && ~lsr5_d);

   // lsr bit 6 (transmitter empty indicator)


   always @(posedge clk )
     if (wb_rst_i) lsr6_d <=  1;
     else lsr6_d <=  lsr6;

   always @(posedge clk )
     if (wb_rst_i) lsr6r <=  1;
     else lsr6r <=  (fifo_write) ? 0 : lsr6r || (lsr6 && ~lsr6_d);

   // lsr bit 7 (error in fifo)


   always @(posedge clk )
     if (wb_rst_i) lsr7_d <=  0;
     else lsr7_d <=  lsr7;

   always @(posedge clk )
     if (wb_rst_i) lsr7r <=  0;
     else lsr7r <=  lsr_mask ? 0 : lsr7r || (lsr7 && ~lsr7_d);

   // Frequency divider
   always @(posedge clk ) 
     begin
    if (wb_rst_i)
      dlc <=  0;
    else
      if (start_dlc | ~ (|dlc))
          dlc <=  dl - 1;               // preset counter
      else
        dlc <=  dlc - 1;              // decrement counter
     end

   // Enable signal generation logic
   always @(posedge clk )
     begin
    if (wb_rst_i)
      enable <=  1'b0;
    else
      if (|dl & ~(|dlc))     // dl>0 & dlc==0
        enable <=  1'b1;
      else
        enable <=  1'b0;
     end

   // Delaying THRE status for one character cycle after a character is written to an empty fifo.
   always @(lcr)
     case (lcr[3:0])
       4'b0000                             : block_value =  95; // 6 bits
       4'b0100                             : block_value = 103; // 6.5 bits
       4'b0001, 4'b1000                    : block_value = 111; // 7 bits
       4'b1100                             : block_value = 119; // 7.5 bits
       4'b0010, 4'b0101, 4'b1001           : block_value = 127; // 8 bits
       4'b0011, 4'b0110, 4'b1010, 4'b1101  : block_value = 143; // 9 bits
       4'b0111, 4'b1011, 4'b1110           : block_value = 159; // 10 bits
       4'b1111                             : block_value = 175; // 11 bits
     endcase // case(lcr[3:0])

   // Counting time of one character minus stop bit
   always @(posedge clk )
     begin
    if (wb_rst_i)
      block_cnt <=  8'd0;
    else
      if(lsr5r & fifo_write)  // THRE bit set & write to fifo occured
        block_cnt <=  block_value;
      else
        if (enable & block_cnt != 8'b0)  // only work on enable times
          block_cnt <=  block_cnt - 1;  // decrement break counter
     end // always of break condition detection

   // Generating THRE status enable signal
   assign thre_set_en = ~(|block_cnt);


   //
   //    INTERRUPT LOGIC
   //

   assign rls_int  = ier[`UART_IE_RLS]  && (lsr[`UART_LS_OE] || lsr[`UART_LS_PE] || lsr[`UART_LS_FE] || lsr[`UART_LS_BI]);
   assign rda_int  = ier[`UART_IE_RDA]  && (rf_count >= {1'b0,trigger_level});
   assign thre_int = ier[`UART_IE_THRE] &&  lsr[`UART_LS_TFE];
   assign ms_int   = ier[`UART_IE_MS]   && (| msr[3:0]);
   assign ti_int   = ier[`UART_IE_RDA]  && (counter_t == 10'b0) && (|rf_count);





   // delay lines
   always  @(posedge clk )
     if (wb_rst_i) rls_int_d <=  0;
     else rls_int_d <=  rls_int;

   always  @(posedge clk )
     if (wb_rst_i) rda_int_d <=  0;
     else rda_int_d <=  rda_int;

   always  @(posedge clk )
     if (wb_rst_i) thre_int_d <=  0;
     else thre_int_d <=  thre_int;

   always  @(posedge clk )
     if (wb_rst_i) ms_int_d <=  0;
     else ms_int_d <=  ms_int;

   always  @(posedge clk )
     if (wb_rst_i) ti_int_d <=  0;
     else ti_int_d <=  ti_int;

   // rise detection signals



   assign rda_int_rise      = rda_int & ~rda_int_d;
   assign rls_int_rise      = rls_int & ~rls_int_d;
   assign thre_int_rise     = thre_int & ~thre_int_d;
   assign ms_int_rise       = ms_int & ~ms_int_d;
   assign ti_int_rise       = ti_int & ~ti_int_d;

   // interrupt pending flags


   // interrupt pending flags assignments
   always  @(posedge clk )
     if (wb_rst_i) rls_int_pnd <=  0; 
     else 
       rls_int_pnd <=  lsr_mask ? 0 :                          // reset condition
               rls_int_rise ? 1 :                        // latch condition
               rls_int_pnd && ier[`UART_IE_RLS];    // default operation: remove if masked

   always  @(posedge clk )
     if (wb_rst_i) rda_int_pnd <=  0; 
     else 
       rda_int_pnd <=  ((rf_count == {1'b0,trigger_level}) && fifo_read) ? 0 :      // reset condition
               rda_int_rise ? 1 :                        // latch condition
               rda_int_pnd && ier[`UART_IE_RDA];    // default operation: remove if masked

   always  @(posedge clk )
     if (wb_rst_i) thre_int_pnd <=  0; 
     else 
       thre_int_pnd <=  fifo_write || (iir_read & ~iir[`UART_II_IP] & iir[`UART_II_II] == `UART_II_THRE)? 0 : 
            thre_int_rise ? 1 :
            thre_int_pnd && ier[`UART_IE_THRE];

   always  @(posedge clk )
     if (wb_rst_i) ms_int_pnd <=  0; 
     else 
       ms_int_pnd <=  msr_read ? 0 : 
              ms_int_rise ? 1 :
              ms_int_pnd && ier[`UART_IE_MS];

   always  @(posedge clk )
     if (wb_rst_i) ti_int_pnd <=  0; 
     else 
       ti_int_pnd <=  fifo_read ? 0 : 
              ti_int_rise ? 1 :
              ti_int_pnd && ier[`UART_IE_RDA];
   // end of pending flags

   // INT_O logic
   always @(posedge clk )
     begin
    if (wb_rst_i)    
      int_o <=  1'b0;
    else
      int_o <=  
            rls_int_pnd        ?    ~lsr_mask             :
            rda_int_pnd        ? 1                        :
            ti_int_pnd         ? ~fifo_read               :
            thre_int_pnd       ? !(fifo_write & iir_read) :
            ms_int_pnd         ? ~msr_read                :
            0;    // if no interrupt are pending
     end


   // Interrupt Identification register
   always @(posedge clk )
     begin
    if (wb_rst_i)
      iir <=  1;
    else
      if (rls_int_pnd)  // interrupt is pending
        begin
           iir[`UART_II_II] <=  `UART_II_RLS;    // set identification register to correct value
           iir[`UART_II_IP] <=  1'b0;        // and clear the IIR bit 0 (interrupt pending)
        end else // the sequence of conditions determines priority of interrupt identification
          if (rda_int)
        begin
           iir[`UART_II_II] <=  `UART_II_RDA;
           iir[`UART_II_IP] <=  1'b0;
        end
          else if (ti_int_pnd)
        begin
           iir[`UART_II_II] <=  `UART_II_TI;
           iir[`UART_II_IP] <=  1'b0;
        end
          else if (thre_int_pnd)
        begin
           iir[`UART_II_II] <=  `UART_II_THRE;
           iir[`UART_II_IP] <=  1'b0;
        end
          else if (ms_int_pnd)
        begin
           iir[`UART_II_II] <=  `UART_II_MS;
           iir[`UART_II_IP] <=  1'b0;
        end else    // no interrupt is pending
          begin
             iir[`UART_II_II] <=  0;
             iir[`UART_II_IP] <=  1'b1;
          end
     end

endmodule
